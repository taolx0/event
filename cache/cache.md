1. 什么是 cache aside 模式？

应用程序和关系型数据库之间,加入一层缓存,可以是基于LRU算法的内存缓存(https://github.com/hashicorp/golang-lru)
,也可以是redis等缓存数据库.

LRU算法的内存缓存:

```
package main

import (
	"fmt"

	"github.com/golang/groupcache/lru"
)

func main() {
	l, _ := lru.New[int, any](128)
	for i := 0; i < 256; i++ {
		l.Add(i, nil)
	}
	if l.Len() != 128 {
		panic(fmt.Sprintf("bad len: %v", l.Len()))
	}
}
```

2. 使用 cache aside 模式需要注意的问题

**缓存穿透**: 查询一个不存在的数据,缓存不命中,每次都要查询数据库,导致硬盘I/O压力过大.

解决方案:

- 查询缓存为空,将空值写入redis,设置较短的时间,减少磁盘I/O压力.
- 使用布隆过滤器,来判断元素是否存在,如果在布隆过滤器中不存在,则数据一定不存在,直接返回,不再查询数据库.
- 通过验证码,限制IP请求频率,防止缓存穿透.
- 通过熔断机制,当系统负载过高,限流,降级,保护系统.

**缓存雪崩**: redis中的数据同时过期,导致大量请求直接打到数据库,导致数据库宕机.

解决方案:

- 热点数据设置永不过期
- 在过期时间的尾部增加随机数
- 优化数据库,优化表结构设计,增加索引,提高查询效率,引入读写分离,提高数据库性能.

**缓存一致性**: 缓存数据与数据库数据不一致

解决方案:

- 先更新数据库再更新缓存
- 使用消息队列异步更新redis数据

**缓存容量限制**: 缓存容量有限,需要淘汰部分缓存数据.

解决方案:

- 使用LRU（Least Recently Used）算法,淘汰最少使用的数据

**分布式缓存一致性**:分布式环境下，多个缓存节点之间的数据一致性问题

解决方案:

- 使用分布式锁,保证同一时刻只有一个节点更新缓存,常见的有redis
- 消息队列,异步更新缓存